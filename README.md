# AofC_2021
Learning F# by doing [AdventOfCode 2021](https://adventofcode.com/2021)

##Autogenerated##
## [Day 1 - Sonar Sweep](https://adventofcode.com/2021/day/1)
[Source](AofC_2021/D1.fs) | [Input](AofC_2021/D1.txt)  
### part1
```FSharp
let part1 input =
    countIncreases (parseInput input)
```
Result (in `10`ms): `1709`
### part2
```FSharp
let part2 input =
    countIncreases ((parseInput input) |> Array.windowed 3 |> Array.map (fun f -> f |> Array.sum))
```
Result (in `1`ms): `1761`
## [Day 2 - Dive!](https://adventofcode.com/2021/day/2)
[Source](AofC_2021/D2.fs) | [Input](AofC_2021/D2.txt)  
### part1
```FSharp
let part1 input =
    let data = parseInput input
    let final = data |> Array.fold (fun (agg: Vector2D) curr -> 
                    let vector = directionToVector curr.Direction curr.Amount
                    agg.Add vector
                ) Vector2D.Zero
    final.X * final.Y
```
Result (in `2`ms): `1648020`
### part2
```FSharp
let part2 input =
    let data = parseInput input
    let final = data |> Array.fold (fun (agg: {| Aim: int; Position: Vector2D |}) curr -> 
                    let vector = directionToVector curr.Direction curr.Amount
                    if vector.X = 0 then {| Aim = agg.Aim + vector.Y; Position = agg.Position |}
                    else {| Aim = agg.Aim; Position = { X = agg.Position.X + vector.X; Y = agg.Position.Y + agg.Aim * vector.X } |}
                ) {| Aim = 0; Position = Vector2D.Zero |}

    final.Position.X * final.Position.Y
```
Result (in `1`ms): `1759818555`
## [Day 3 - Binary Diagnostic](https://adventofcode.com/2021/day/3)
[Source](AofC_2021/D3.fs) | [Input](AofC_2021/D3.txt)  
### part1
```FSharp
let part1 input =
    let data = parseInput input
    let numItems = data.Length
    let indexArray =  [| 0 .. data.[0].Length - 1|]

    let num1PerColumn = indexArray |> Array.map (fun col -> data |> Array.filter (fun cell -> cell.Chars(col) = '1') |> Array.length)

    let calc func =indexArray |> Array.map (fun columnIndex ->
        func (int (num1PerColumn.[columnIndex]))) |> Array.map (fun f -> if f then "1" else "0") |> String.concat ""

    let fGamma value = value > (numItems / 2)
    let fEpsilon value = value < (numItems / 2)
    goForthAndMultiply [| fGamma; fEpsilon;|] calc
```
Result (in `5`ms): `4174964`
### part2
```FSharp
let part2 input =
    let data = parseInput input
    let indexArray =  [| 0 .. data.[0].Length - 1|]

    let sieve bitCriterium index (rows: string[]) =
        let num1s = rows |> Array.filter (fun cell -> cell.Chars(index) = '1') |> Array.length
        let filterValue = if (bitCriterium num1s rows.Length) then '1' else '0'
        rows |> Array.filter (fun row -> row.[index] = filterValue)

    let lifeSupportCalc bitCriterium = 
        indexArray |> Array.fold (fun (agg: string []) curr -> 
            if agg.Length = 1 then agg else sieve bitCriterium curr agg ) data
            |> String.concat ""

    let oxy = (fun num1s total -> num1s * 2 >= total)
    let co2 = (fun num1s total -> (num1s * 2 >= total) = false)

    goForthAndMultiply [| oxy; co2;|] lifeSupportCalc
```
Result (in `2`ms): `4474944`
## [Day 4 - Giant Squid](https://adventofcode.com/2021/day/4)
[Source](AofC_2021/D4.fs) | [Input](AofC_2021/D4.txt)  
### part1
```FSharp
let part1 input =
    let (draws, boards) = parseInput input

    let findWinningBoard boards = boards |> Array.tryFind hasBoardWon
    let (firstWinner, draw) = draws |> Array.fold (fun agg curr -> 
                                    let winning = findWinningBoard (fst agg)
                                    if winning = None then
                                        ((fst agg) |> Array.map (fun b -> markedBoard b curr), curr)
                                    else
                                        ([|winning.Value|], snd agg)
                                ) (boards, "")
    (getSumOfLeftovers firstWinner.[0]) * (int draw)
```
Result (in `43`ms): `69579`
### part2
```FSharp
let part2 input =
    let (draws, boards) = parseInput input
    
    let (notWon, won, draw) = draws |> Array.fold (fun agg curr -> 
                                    let (notWon, won, preDraw) = agg
                                    let mods = notWon |> Array.map (fun b -> markedBoard b curr)
                                    let newWons = mods |> Array.filter hasBoardWon
                                    if newWons.Length = 0 then (mods, won, preDraw)
                                    else (mods |> Array.except newWons, won |> Array.append newWons, curr)
                                ) (boards, Array.zeroCreate<string> 0, "!")

    if won.Length = 0 then 0
    else
        let lastWinner = won.[0] // reversed order
        let finalDraw = int draw
        let sumOfLeftovers = getSumOfLeftovers lastWinner
        sumOfLeftovers * finalDraw
```
Result (in `79`ms): `14877`
## [Day 5 - Hydrothermal Venture](https://adventofcode.com/2021/day/5)
[Source](AofC_2021/D5.fs) | [Input](AofC_2021/D5.txt)  
### part1
```FSharp
let part1 input =
    let (boardCoords, lines) = parseInput input
    let boardArray = drawLines boardCoords (lines |> Array.filter (fun el -> el.Start.X = el.End.X || el.Start.Y = el.End.Y))
    boardArray |> Array.filter (fun el -> el > 1) |> Array.length
```
Result (in `176`ms): `7297`
### part2
```FSharp
let part2 input =
    let (boardCoords, lines) = parseInput input
    let boardArray = drawLines boardCoords lines
    boardArray |> Array.filter (fun el -> el > 1) |> Array.length
```
Result (in `210`ms): `21038`
## [Day 6 - Lanternfish](https://adventofcode.com/2021/day/6)
[Source](AofC_2021/D6.fs) | [Input](AofC_2021/D6.txt)  
### part1
```FSharp
let part1 input =
    let school = parseInput input
    let finalDay = 80

    let final = [|1 .. finalDay|] |> Array.fold (fun agg curr -> 
                let ready = agg |> Array.filter (fun f -> f = 0);
                let aged = agg |> Array.filter (fun f -> f > 0) |> Array.map (fun f -> f - 1)
                let spawned = ready |> Array.map (fun f -> 8)
                let newSchool = aged |> Array.append spawned |> Array.append (ready |> Array.map(fun f -> 6))
                newSchool
                ) school
    final.Length
```
Result (in `87`ms): `358214`
### part2
```FSharp
let part2 input =
    let data = parseInput input
    let finalDay = 256

    let mutable numPerCounter = Array.zeroCreate 9 |> Array.map (fun f -> 0UL)
    for item in data do
        numPerCounter.[item] <- numPerCounter.[item] + 1UL
    for day in [|1 .. finalDay|] do
        let numMature = numPerCounter.[0]
        for index in [|1..numPerCounter.Length-1|] do
            numPerCounter.[index - 1] <- numPerCounter.[index]
        numPerCounter.[8] <- numMature // new fish
        numPerCounter.[6] <- numPerCounter.[6] + numMature

    numPerCounter |> Array.sum
```
Result (in `0`ms): `1622533344325`
## [Day 7 - The Treachery of Whales](https://adventofcode.com/2021/day/7)
[Source](AofC_2021/D7.fs) | [Input](AofC_2021/D7.txt)  
### part1
```FSharp
let part1 input =
    calc (parseInput input) (fun p1 p2 -> abs(p1 - p2))
```
Result (in `33`ms): `336040`
### part2
```FSharp
let part2 input =
    calc (parseInput input) (fun p1 p2 -> 
        let diff = abs(p1 - p2)
        diff * (diff + 1) / 2
    )
```
Result (in `34`ms): `94813675`
## [Day 8 - Seven Segment Search](https://adventofcode.com/2021/day/8)
[Source](AofC_2021/D8.fs) | [Input](AofC_2021/D8.txt)  
### part1
```FSharp
let part1 input =
    let data = parseInput input

    let numberToSegments = digitsWithSegments |> Array.map (fun f -> (f.Digit, f.Segments)) |> Map.ofArray
    let byNumSegments = [| for (KeyValue(k, v)) in numberToSegments -> (k, v.Length) |] |> Array.groupBy (fun f -> snd f)
    let singleInstances = byNumSegments |> Array.filter (fun f -> (snd f).Length = 1)
    let singleInstanceSegmentCounts = singleInstances |> Array.map (fun f -> fst f)

    let outputLengths = data |> Array.map (fun f -> f.Output |> Array.map (fun item -> item.Length))
                        |> Array.reduce Array.append

    let counts = outputLengths |> Array.filter (fun f -> singleInstanceSegmentCounts |> Array.contains f ) |> Array.length
    counts
```
Result (in `31`ms): `445`
### part2
```FSharp
let part2 input =
    let data = parseInput input
    // Note: Wanted to "brute force" by identifying the digit segments, then translating to digits

    let groupBySegment arrWithSegments  =
        let all = arrWithSegments |> Array.map (fun f -> f.Segments) |> String.concat "" |> Seq.toArray |> Array.distinct
        all |> Array.map (fun char -> 
            let containedIn = arrWithSegments |> Array.filter (fun ds -> (ds.Segments).Contains(char)) |> Array.map (fun f -> f.Digit)
            {| Segment = char; ContainedIn = containedIn |}
        )
    
    let getUniqueFreqs segFreqs =
        segFreqs |> Array.groupBy (fun (f: {| ContainedIn: 'a[]; Segment: char; |}) ->
            f.ContainedIn |> Array.length) |> Array.filter (fun f -> (snd f).Length = 1) |> Array.map (fun f -> (snd f).[0])

    let removeSegments digSeg segments =
        digSeg |> Array.map (fun f -> { f with Segments = removeCharsFromString f.Segments segments })

    let identifySegments sigsegs =
        let uniqueSegFreqs = getUniqueFreqs (groupBySegment sigsegs) |> Array.sortBy (fun f -> f.ContainedIn.Length)
        let identifiedSeqments = mapToString uniqueSegFreqs (fun f -> f.Segment)

        let withSingleAfterRemoval segmentsToRemove (ignoreSegments: string) =
            let withRemoved = removeSegments sigsegs segmentsToRemove
            withRemoved |> Array.filter (fun f -> f.Segments.Length = 1) 
                    |> Array.filter (fun f -> ignoreSegments.Contains(f.Segments) = false)
                    |> Array.tryExactlyOne

        let identifySegment segmentsToRemove =
            let combos = segmentsToRemove |> getCombinationsString
            let found = combos |> List.map (fun combo -> withSingleAfterRemoval combo segmentsToRemove) |> List.tryFind (fun f -> f.IsSome)
            let foundOption = if found.IsSome && found.Value.IsSome then Some(found.Value.Value) else None
            foundOption

        let foldResult = [|0..7|] |> Array.fold (fun (agg: {| IdentifiedSegments: string; Continue: bool; |}) curr -> 
                                if agg.Continue = false then agg
                                else
                                let found = identifySegment agg.IdentifiedSegments
                                let segments = agg.IdentifiedSegments + if found.IsNone then "" else found.Value.Segments.[0].ToString()
                                {| IdentifiedSegments = segments; Continue = found.IsSome; |}
                            ) {| IdentifiedSegments = identifiedSeqments;  Continue = true |}
        foldResult.IdentifiedSegments

    let realOrder = identifySegments digitsWithSegments |> Seq.toArray
    let segmentsToDigit = Map (Array.zip(digitsWithSegments |> Array.map (fun f -> f.Segments)) (digitsWithSegments |> Array.map (fun f -> f.Digit)))

    let translateInputToReal digSeg output =
        let inputOrder = identifySegments digSeg |> Seq.toArray
        let inputSegment2Real = Map (Array.zip inputOrder realOrder)
        let translatedInputSegments = output |> Array.map Seq.toArray 
                                        |> Array.map (fun f -> f |> Array.map (fun c -> inputSegment2Real.[c]) |> Array.sort |> Array.map string |> String.concat "")
        let digits = translatedInputSegments |> Array.map (fun f -> segmentsToDigit.[f])
        digits |> Array.map string |> String.concat "" |> int

    let translatedOutput = data |> Array.map (fun f -> translateInputToReal f.SignalNormalized f.Output)
    let sum = translatedOutput |> Array.sum
    sum
```
Result (in `963`ms): `1043101`
## [Day 9 - Smoke Basin](https://adventofcode.com/2021/day/9)
[Source](AofC_2021/D9.fs) | [Input](AofC_2021/D9.txt)  
### part1
```FSharp
let part1 input =
    let map = createDepthMap input
    map.findLowPoints |> Array.map map.getAtPoint |> Array.map (fun f -> f + 1) |> Array.sum
```
Result (in `13`ms): `535`
### part2
```FSharp
let part2 input =
    let map = createDepthMap input

    let visited = new System.Collections.Generic.List<Point>()
    let basinsBySize = map.findLowPoints |> Array.map (fun f -> exploreBasin map f visited |> List.toArray) |> Array.sortBy (fun f -> f.Length) |> Array.rev

    let html = basinsToHtml map basinsBySize
    System.IO.File.WriteAllText(@"Basins.html", html);
    let top3 = basinsBySize |> Array.take 3
    top3 |> Array.map (fun f -> f.Length) |> Array.reduce (fun agg curr -> agg * curr)
```
Result (in `837`ms): `1122700`
## [Day 10 - Syntax Scoring](https://adventofcode.com/2021/day/10)
[Source](AofC_2021/D10.fs) | [Input](AofC_2021/D10.txt)  
### part1
```FSharp
let part1 (input: string) =
    let data = parseInput input
    let analyzed = data |> Array.map (fun f -> {| Line = f; Analysis = findCorrupt f;|})
    let pointsPt1 = Map([(')', 3); (']', 57); ('}', 1197); ('>', 25137)])
    analyzed
        |> Array.filter (fun f -> f.Analysis.Corrupt)
        |> Array.map (fun f -> f.Line.[f.Analysis.LastIndex])
        |> Array.map (fun f -> pointsPt1.[f])
        |> Array.sum
```
Result (in `6`ms): `318081`
### part2
```FSharp
let part2 (input: string) =
    let data = parseInput input
    let analyzed = data |> Array.map (fun f -> {| Line = f; Analysis = findCorrupt f;|})
    let pointsPt2 = Map([(')', 1); (']', 2); ('}', 3); ('>', 4)])
    let part2 = analyzed
                |> Array.filter (fun f -> f.Analysis.Corrupt = false)
                |> Array.map (fun f -> f.Analysis.Stack |> List.map (fun c -> pointsPt2.[getMatchingChar c]) |> List.map int64 |> List.reduce (fun agg c -> agg * 5L + c))
                |> Array.sort
    part2.[part2.Length / 2]
```
Result (in `8`ms): `4361305341`
## [Day 11 - Dumbo Octopus](https://adventofcode.com/2021/day/11)
[Source](AofC_2021/D11.fs) | [Input](AofC_2021/D11.txt)  
### part1
```FSharp
let part1 input =
    let data = prepare input
    let (_, numFlashes) = [|1..100|] |> Array.fold (fun agg curr -> 
                                    let state = performStep (fst agg) data.Size
                                    let numFlashes = state |> Array.filter (fun f -> f = 0) |> Array.length
                                    (state, (snd agg) + numFlashes)
                                    ) (data.Values, 0)
    numFlashes
```
Result (in `25`ms): `1679`
### part2
```FSharp
let part2 input =
    let data = prepare input
    let rec folder vals step =
        let state = performStep vals data.Size
        if state |> Array.filter (fun f -> f > 0) |> Array.length = 0 then step
        else folder state step + 1
    folder data.Values 1
```
Result (in `67`ms): `519`
## [Day 12 - Passage Pathing](https://adventofcode.com/2021/day/12)
[Source](AofC_2021/D12.fs) | [Input](AofC_2021/D12.txt)  
### part1
```FSharp
let part1 input =
    let pairs = parseInput input
    let paths = evaluate pairs (fun f ->  if f.ToUpper() = f then -1 else 1)
    paths.Length
```
Result (in `91`ms): `4413`
### part2
```FSharp
let part2 input =
    let pairs = parseInput input
    let allSmall = (getNodes pairs) |> Array.filter (fun f -> f.ToLower() = f) |> Array.except [| "start"; "end" |]
    let allPaths = allSmall |> Array.map (fun small -> 
        evaluate pairs (fun f -> if f.ToUpper() = f then -1 else if f = small then 2 else 1)
    )

    let distinct = allPaths |> Array.reduce Array.append |> Array.distinct
    distinct.Length
```
Result (in `2055`ms): `118803`
## [Day 13 - Transparent Origami](https://adventofcode.com/2021/day/13)
[Source](AofC_2021/D13.fs) | [Input](AofC_2021/D13.txt)  
### part1
```FSharp
let part1 input =
    let data = parseInput input
    let folded = fold data.Folds.[0] data.Points
    folded |> Array.length
```
Result (in `2`ms): `847`
### part2
```FSharp
let part2 input =
    let data = parseInput input
    let folded = data.Folds |> Array.fold (fun agg curr -> fold curr agg) data.Points

    let grid = Grid2D.FromCoordinates folded
    let mutable bm = [|0..grid.Size.Y-1|] |> Array.map (fun y -> [|0..grid.Size.X-1|] |> Array.map (fun x -> '.'))

    for pt in folded |> Array.map (fun pt -> { X = pt.X - grid.TopLeft.X; Y = pt.Y - grid.TopLeft.Y }) do
        bm.[pt.Y].[pt.X] <- '#'

    bm |> Array.map (fun r -> r |> Array.map string |> String.concat "") |> String.concat "\n"
```
Result (in `3`ms): 
```
###...##..####.###...##..####..##..###.
#..#.#..#....#.#..#.#..#.#....#..#.#..#
###..#......#..#..#.#....###..#..#.###.
#..#.#.....#...###..#....#....####.#..#
#..#.#..#.#....#.#..#..#.#....#..#.#..#
###...##..####.#..#..##..####.#..#.###.
```
## [Day 14 - Extended Polymerization](https://adventofcode.com/2021/day/14)
[Source](AofC_2021/D14.fs) | [Input](AofC_2021/D14.txt)  
### part1
```FSharp
let part1 input =
    let (template, rules) = parseInput input

    let folder template (rules: Map<string, string[]>) =
        let pairs = windowedStrings 2 (template + " ")
        let expand pair = 
            if rules.ContainsKey pair then $"{rules[pair].[0]}"
            else $"{pair.[0]}"
        pairs |> Array.map (fun f -> expand f) |> String.concat ""

    let folded = [|1..10|] |> Array.fold (fun agg _ -> folder agg rules) template

    let cntByCharSorted = folded |> Seq.toArray |> Array.groupBy (fun f -> f) |> Array.map (fun f -> (fst f, (snd f).Length)) |> Array.sortBy (fun f -> snd f)
    (snd (Array.last cntByCharSorted) - (snd cntByCharSorted.[0]))
```
Result (in `21`ms): `2447`
### part2
```FSharp
let part2 input =
    let (template, rules) = parseInput input

    let initiateFromTemplate str =
        str |> windowedStrings 2 |> Array.filter (fun f-> rules.ContainsKey(f))
                            |> Array.map (fun f -> (f, 1UL))
                            |> Array.groupBy (fun f -> fst f) |> Array.map (fun f -> (fst f, (snd f) |> Array.sumBy (fun p -> snd p)))

    let folder cntPerRule = 
        cntPerRule |>
            Array.map (fun kv ->
                let pair = fst kv
                let currCnt = snd kv
                let (found, mutations) = rules.TryGetValue pair
                if currCnt > 0UL && found then
                    mutations |> Array.map (fun mutation -> (mutation, currCnt))
                else [||]
            ) |> Array.reduce Array.append |> Array.groupBy(fun f-> fst f) |> Array.map (fun f -> (fst f, (snd f) |> Array.sumBy (fun p -> snd p)))

    let folded = [|1..40|] |> Array.fold (fun agg _ -> folder agg) (initiateFromTemplate template)

    let cntByChar = folded 
                        |> Array.map (fun f -> ((fst f).[0], snd f))
                        |> Array.groupBy (fun f -> fst f) |> Array.map (fun f -> (fst f, (snd f) |> Array.sumBy (fun p -> snd p)))

    // last char in template is never first in a pair - add 1 for its count
    let lastTemplateChar = template |> Seq.toArray |> Array.last
    let withExtraFinal = cntByChar |> Array.map (fun f -> (fst f, if (fst f) = lastTemplateChar then 1UL + (snd f) else snd f))
    let sorted = withExtraFinal |> Array.sortBy (fun f -> snd f)
    (snd (Array.last sorted) - (snd sorted.[0]))
```
Result (in `12`ms): `3018019237563`
## [Day 15 - Chiton](https://adventofcode.com/2021/day/15)
[Source](AofC_2021/D15.fs) | [Input](AofC_2021/D15.txt)  
### part1
```FSharp
let part1 (input: string) =
    let data = parseInput input
    let grid = { Size = { X = data.Length; Y = data.[0].Length; }; TopLeft = Vector2D.Zero }

    let allCosts = getCostPerCoordinate data grid grid.TopLeft grid.BottomRight
    let (found, info) = allCosts.TryGetValue(grid.BottomRight)
    if found = false then raise (new System.Exception("No path to end node!"))

    fst info
```
Result (in `85`ms): `811`
### part2
```FSharp
let part2 (input: string) =
    let data = mutateGrid (parseInput input) { X = 5; Y = 5;}
    let grid = { Size = { X = data.Length; Y = data.[0].Length; }; TopLeft = Vector2D.Zero }

    let allCosts = getCostPerCoordinate data grid grid.TopLeft grid.BottomRight
    let (found, info) = allCosts.TryGetValue(grid.BottomRight)
    if found = false then raise (new System.Exception("No path to end node!"))

    fst info
```
Result (in `1925`ms): `3012`
## [Day 16 - Packet Decoder](https://adventofcode.com/2021/day/16)
[Source](AofC_2021/D16.fs) | [Input](AofC_2021/D16.txt)  
### part1
```FSharp
let part1 (input:string) =
    let bin = parseInput input
    let (_, root) = parsePackage bin 0

    let flatten (packet) = 
        let rec loop (p: Packet) = seq {
            yield p
            match p.Content with
            | Value v -> ()
            | Op o ->
                for c in o.Children do
                    yield! loop c
        }

        loop packet |> Seq.toArray

    let flattened = flatten root
    let versionSum = flattened |> Array.sumBy (fun f -> f.Header.Version)
    versionSum
```
Result (in `9`ms): `943`
### part2
```FSharp
let part2 (input:string) =
    let bin = parseInput input
    let (_, root) = parsePackage bin 0

    let rec reducer node =
        match node.Content with
        | Value v -> v.Value
        | Op o ->
            let childValues = o.Children |> Array.map (fun f -> reducer f)
            match node.Header.TypeId with
            | 0 -> childValues |> Array.sum
            | 1 -> childValues |> Array.reduce (fun p c -> p * c)
            | 2 -> childValues |> Array.min
            | 3 -> childValues |> Array.max
            | 5 -> if childValues.[0] > childValues.[1] then 1UL else 0UL
            | 6 -> if childValues.[0] < childValues.[1]  then 1UL else 0UL
            | 7 -> if childValues.[0] = childValues.[1]  then 1UL else 0UL
            | _ -> raise (new System.Exception("Unknown type"))
            
    let result = reducer root
    result
```
Result (in `2`ms): `167737115857`
## [Day 17 - Trick Shot](https://adventofcode.com/2021/day/17)
[Source](AofC_2021/D17.fs) | [Input](AofC_2021/D17.txt)  
### part1
```FSharp
let part1 input =
    let target = parseInput input

    let maxXToReach = [|1..target.BottomRight.X|] |> Array.filter(fun f ->
        let tri = getTriangularNumber f
        if tri < target.BottomRight.X && tri >= target.TopLeft.X then true else false) |> Array.min

    let velYsAndHits = [|-10..100|] 
                        |> Array.map (fun velY -> 
                            let r = simulate Vector2D.Zero { X = maxXToReach; Y = velY } target
                            (velY, r)
                        ) |> Array.filter (fun (_, hit) -> hit.IsSome)
    let maxVel = velYsAndHits |> Array.map(fun (velY, _) -> velY) |> Array.max
    getTriangularNumber maxVel
```
Result (in `5`ms): `5050`
### part2
```FSharp
let part2 input = 
    let target = parseInput input
    //TODO: equation instead of brute-force?

    let possibleXs = [|1..target.BottomRight.X|] |> Array.filter(fun velX ->
        let isInside x = x >= target.Left && x <= target.Right
        let endpoints = [|0..velX-1|] |> Array.map (fun numSteps -> 
            let tri1 = getTriangularNumber velX
            let tri2 = getTriangularNumber (velX - numSteps)
            tri1 - tri2)
        let valid = endpoints |> Array.filter(fun v -> isInside v)
        valid.Length > 0
    )

    let combos = possibleXs |> Array.map (fun velX ->
        let velYsAndHits = [|-1000..1000|] |> Array.map (fun velY -> 
            let r = simulate Vector2D.Zero { X = velX; Y = velY } target
            (velY, r)
        )
        let found = velYsAndHits |> Array.filter(fun f -> (snd f).IsSome) |> Array.map(fun f -> fst f)
        found |> Array.map (fun velY -> { X = velX; Y = velY; })
    )                               
    let flattened = combos |> Array.reduce Array.append
    flattened.Length
```
Result (in `673`ms): `5945`
## [Day 18 - Snailfish](https://adventofcode.com/2021/day/18)
[Source](AofC_2021/D18.fs) | [Input](AofC_2021/D18.txt)  
### part1
```FSharp
let part1 input =
    let numbers = parseInput input //Regex.Split(input.Trim(), @"\r?\n\s*") |> Array.map (fun r -> r.Trim()) |> Array.map parseNumber

    let final = numbers |> Array.reduce (fun p c -> 
        let next = reduce (add p c)
        //printfn "%O" (next.ToNestedString)
        next
    )
    calcMagnitude final
```
Result (in `475`ms): `4124`
### part2
```FSharp
let part2 input =
    let numbers = parseInput input //Regex.Split(input.Trim(), @"\r?\n\s*") |> Array.map (fun r -> r.Trim()) |> Array.map parseNumber

    // part 2:    // [0..numbers.Length-2] |> List.map (fun a -> [(a+1)..numbers.Length-1]
    let combos = [0..numbers.Length-1] |> List.map (fun a -> [0..numbers.Length-1] |> List.map (fun b -> (numbers[a], numbers[b]))) |> List.reduce List.append
    let mags = combos |> List.map (fun f -> 
                                    let added = add (fst f) (snd f)
                                    calcMagnitude (reduce added))
                                    |> List.sort 
    let diff = mags |> List.last
    // 4549 too low
    diff
```
Result (in `6592`ms): `4673`
## [Day 19 - Beacon Scanner](https://adventofcode.com/2021/day/19)
[Source](AofC_2021/D19.fs) | [Input](AofC_2021/D19.txt)  
### part1
```FSharp
let part1 input =
    let data = parseInput input
    let scanners = Map (data |> Map.toList |> List.map (fun (id, points) -> (id, Scanner points)))

    let matchedScannerPoints = analyzeScannerData scanners

    let findConnections id = 
        matchedScannerPoints |> List.filter (fun ((id1, _, _), (id2, _, _)) -> 
            id1 = id || id2 = id) |> List.map (fun ((id1, indices1, x1to2), (id2, indices2, x2to1)) -> if id1 = id then (id2, indices2, x2to1) else (id1, indices1, x1to2))
    
    let rec loop id visited xforms =
        seq {
            let connections = (findConnections id) |> List.filter (fun (idSub, _, _) -> (visited |> List.contains idSub) = false)
            let newVisited = [id] |> List.append visited
            for conn in connections do
                let (idSub, indices, xform) = conn
                let points = scanners[idSub].Points
                let newXforms = xforms |> List.append [xform] 
                let xformed = newXforms |> List.fold(fun agg curr -> agg |> List.map curr ) points
                yield xformed
                yield! loop idSub newVisited newXforms
        }
    let startId = 0
    let allPoints = (loop startId [] []) |> Seq.toList |> List.reduce List.append |> List.append (scanners[startId].Points) |> List.distinct

    allPoints.Length
```
Result (in `5100`ms): `376`
### part2
```FSharp
let part2 input =
    let data = parseInput input
    let scanners = Map (data |> Map.toList |> List.map (fun (id, points) -> (id, Scanner points)))

    let matchedScannerPoints = analyzeScannerData scanners

    let findConnections id = 
        matchedScannerPoints |> List.filter (fun ((id1, _, _), (id2, _, _)) -> 
            id1 = id || id2 = id) |> List.map (fun ((id1, indices1, x1to2), (id2, indices2, x2to1)) -> if id1 = id then (id2, indices2, x2to1) else (id1, indices1, x1to2))
    
    let rec loop id visited xforms =
        seq {
            let connections = (findConnections id) |> List.filter (fun (idSub, _, _) -> (visited |> List.contains idSub) = false)
            let newVisited = [id] |> List.append visited
            for conn in connections do
                let (idSub, _, xform) = conn
                let newXforms = xforms |> List.append [xform]
                let scannerLocation = newXforms |> List.fold(fun agg curr -> curr agg) Vector3D.Zero
                yield scannerLocation
                yield! loop idSub newVisited newXforms
        }
    let startId = 0
    let allPoints = (loop startId [] []) |> Seq.toList |> List.distinct

    let allTaxiLengths = (allPoints |> combinations 2)
                            |> List.map(fun lst -> 
                                let diff = lst[0].Sub lst[1]
                                let taxiLength = System.Math.Abs(diff.X) + System.Math.Abs(diff.Y) + System.Math.Abs(diff.Z)
                                taxiLength
                            ) |> List.sort |> List.rev

    allTaxiLengths |> List.head
```
Result (in `742`ms): `10772`
## [Day 20 - Trench Map](https://adventofcode.com/2021/day/20)
[Source](AofC_2021/D20.fs) | [Input](AofC_2021/D20.txt)  
### part1
```FSharp
let part1 input =
    let (algo, image) = parseInput input
    let final = performPasses 2 algo image

    let num1s = final |> Array.map (fun row -> row |> Array.filter (fun v -> v = 1) |> Array.length) |> Array.sum
    num1s
```
Result (in `49`ms): `5249`
### part2
```FSharp
let part2 input =
    let (algo, image) = parseInput input

    let final = performPasses 50 algo image

    let num1s = final |> Array.map (fun row -> row |> Array.filter (fun v -> v = 1) |> Array.length) |> Array.sum
    num1s
```
Result (in `2275`ms): `15714`
## [Day 21 - Dirac Dice](https://adventofcode.com/2021/day/21)
[Source](AofC_2021/D21.fs) | [Input](AofC_2021/D21.txt)  
### part1
```FSharp
let part1 input =
    let data = parseInput input
    let players = data |> Array.map(fun (player, pos) -> pos) |> Array.toList

    let numThrowsPerTurn = 3
    let turnThrows turn =
        [1..numThrowsPerTurn] |> List.map(fun p -> (turn * 3 + p - 1) % 100 + 1)

    let rec loop turn0 (players: Player list) =
        let throws = turnThrows turn0
        let (newP, modified) = update turn0 (throws |> List.sum) players
        if newP.Score >= 1000 then (turn0, modified)
        else
            loop (turn0+1) modified

    let (turn0, final) = loop 0 players

    let losingPlayer = final |> List.sortBy(fun p -> p.Score) |> List.head
    let result = (turn0 + 1) * numThrowsPerTurn * losingPlayer.Score
    result
```
Result (in `2`ms): `916083`
### part2
```FSharp
let part2 input = 
    let data = parseInput input
    let players = data |> Array.map(fun (_, pos) -> pos) |> Array.toList

    let diracDieSides = 3
    let numThrowsPerTurn = 3

    let allCombosPerTurn = permutations numThrowsPerTurn [1..diracDieSides]
    let countsBySum = allCombosPerTurn |> List.groupBy (fun f -> f |> List.sum) |> List.map (fun (sum, org) -> (sum, org.Length))
    let winAt = 21

    let rec loop turn numUniverses (players: Player list) (cbs: (int * int) list) = seq {
            for (sum, count) in cbs do
                let (newP, modified) = update (turn % 2) sum players
                if newP.Score >= winAt then
                    let winner = if modified[0].Score > modified[1].Score then 0 else 1
                    yield (winner, numUniverses * (uint64 count))
                else
                    yield! loop (turn + 1) (numUniverses * (uint64 count)) modified countsBySum
        }

    let foldWins s =
        s |> Seq.fold (fun (agg: uint64 list) (winner, numUniverses) ->
            let ulWinner = uint64 winner
            let newWins = [
                agg[0] + ((1UL - ulWinner) * numUniverses);
                agg[1] + (ulWinner * numUniverses);
            ]
            newWins
            ) [0UL; 0UL;]

    let resultSets = countsBySum 
                        |> PSeq.map (fun k -> 
                            let s = loop 0 1UL players [k]
                            s |> foldWins
                        )
    let wins = resultSets |> PSeq.toList |> List.reduce (fun p c -> [p[0]+c[0]; p[1]+c[1];])
    let result = wins |> List.max

    result
```
Result (in `14488`ms): `49982165861983`
