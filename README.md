# AofC_2021
Learning F# by doing [AdventOfCode 2021](https://adventofcode.com/2021)

##Autogenerated##
## [D1](AofC_2021/D1.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D1.txt)  
### part1
```
let part1 input =
    countIncreases (parseInput input)
```
Result: `1709`
### part2
```
let part2 input =
    countIncreases ((parseInput input) |> Array.windowed 3 |> Array.map (fun f -> f |> Array.sum))
```
Result: `1761`

## [D2](AofC_2021/D2.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D2.txt)  
### part1
```
let part1 input =
    let data = parseInput input
    let final = data |> Array.fold (fun agg curr -> 
                    let vector = directionToVector curr.Direction curr.Amount
                    { X = agg.X + vector.X; Y = agg.Y + vector.Y; }
                ) { X = 0; Y = 0; }
    final.X * final.Y
```
Result: `1648020`
### part2
```
let part2 input =
    let data = parseInput input
    let final = data |> Array.fold (fun agg curr -> 
                    let vector = directionToVector curr.Direction curr.Amount
                    if vector.X = 0 then {| Aim = agg.Aim + vector.Y; Position = agg.Position |}
                    else  {| Aim = agg.Aim; Position = { X = agg.Position.X + vector.X; Y = agg.Position.Y + agg.Aim * vector.X } |}
                ) {| Aim = 0; Position = { X = 0; Y = 0; } |}

    final.Position.X * final.Position.Y
```
Result: `1759818555`

## [D3](AofC_2021/D3.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D3.txt)  
### part1
```
let part1 input =
    let data = parseInput input
    let numItems = data.Length
    let indexArray =  [| 0 .. data.[0].Length - 1|]

    let num1PerColumn = indexArray |> Array.map (fun col -> data |> Array.filter (fun cell -> cell.Chars(col) = '1') |> Array.length)

    let calc func =indexArray |> Array.map (fun columnIndex ->
        func (int (num1PerColumn.[columnIndex]))) |> Array.map (fun f -> if f then "1" else "0") |> String.concat ""

    let fGamma value = value > (numItems / 2)
    let fEpsilon value = value < (numItems / 2)
    goForthAndMultiply [| fGamma; fEpsilon;|] calc
```
Result: `4174964`
### part2
```
let part2 input =
    let data = parseInput input
    let indexArray =  [| 0 .. data.[0].Length - 1|]

    let sieve bitCriterium index (rows: string[]) =
        let num1s = rows |> Array.filter (fun cell -> cell.Chars(index) = '1') |> Array.length
        let filterValue = if (bitCriterium num1s rows.Length) then '1' else '0'
        rows |> Array.filter (fun row -> row.[index] = filterValue)

    let lifeSupportCalc bitCriterium = 
        indexArray |> Array.fold (fun (agg: string []) curr -> 
            if agg.Length = 1 then agg else sieve bitCriterium curr agg ) data
            |> String.concat ""

    let oxy = (fun num1s total -> num1s * 2 >= total)
    let co2 = (fun num1s total -> (num1s * 2 >= total) = false)

    goForthAndMultiply [| oxy; co2;|] lifeSupportCalc
```
Result: `4474944`

## [D4](AofC_2021/D4.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D4.txt)  
### part1
```
let part1 input =
    let (draws, boards) = parseInput input

    let findWinningBoard boards = boards |> Array.tryFind hasBoardWon
    let (firstWinner, draw) = draws |> Array.fold (fun agg curr -> 
                                    let winning = findWinningBoard (fst agg)
                                    if winning = None then
                                        ((fst agg) |> Array.map (fun b -> markedBoard b curr), curr)
                                    else
                                        ([|winning.Value|], snd agg)
                                ) (boards, "")
    (getSumOfLeftovers firstWinner.[0]) * (int draw)
```
Result: `69579`
### part2
```
let part2 input =
    let (draws, boards) = parseInput input
    
    let (notWon, won, draw) = draws |> Array.fold (fun agg curr -> 
                                    let (notWon, won, preDraw) = agg
                                    let mods = notWon |> Array.map (fun b -> markedBoard b curr)
                                    let newWons = mods |> Array.filter hasBoardWon
                                    if newWons.Length = 0 then (mods, won, preDraw)
                                    else (mods |> Array.except newWons, won |> Array.append newWons, curr)
                                ) (boards, Array.zeroCreate<string> 0, "!")

    if won.Length = 0 then 0
    else
        let lastWinner = won.[0] // reversed order
        let finalDraw = int draw
        let sumOfLeftovers = getSumOfLeftovers lastWinner
        sumOfLeftovers * finalDraw
```
Result: `14877`

## [D5](AofC_2021/D5.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D5.txt)  
### part1
```
let part1 input =
    let (boardCoords, lines) = parseInput input
    let boardArray = drawLines boardCoords (lines |> Array.filter (fun el -> el.Start.X = el.End.X || el.Start.Y = el.End.Y))
    boardArray |> Array.filter (fun el -> el > 1) |> Array.length
```
Result: `7297`
### part2
```
let part2 input =
    let (boardCoords, lines) = parseInput input
    //printf "%O\n" (boardToString board2 size.X)
    let boardArray = drawLines boardCoords lines
    boardArray |> Array.filter (fun el -> el > 1) |> Array.length
```
Result: `21038`

## [D6](AofC_2021/D6.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D6.txt)  
### part1
```
let part1 input =
    let school = parseInput input
    let finalDay = 80

    let final = [|1 .. finalDay|] |> Array.fold (fun agg curr -> 
                let ready = agg |> Array.filter (fun f -> f = 0);
                let aged = agg |> Array.filter (fun f -> f > 0) |> Array.map (fun f -> f - 1)
                let spawned = ready |> Array.map (fun f -> 8)
                let newSchool = aged |> Array.append spawned |> Array.append (ready |> Array.map(fun f -> 6))
                newSchool
                ) school
    final.Length
```
Result: `358214`
### part2
```
let part2 input =
    let data = parseInput input
    let finalDay = 256

    let mutable numPerCounter = Array.zeroCreate 9 |> Array.map (fun f -> 0UL)
    for item in data do
        numPerCounter.[item] <- numPerCounter.[item] + 1UL
    for day in [|1 .. finalDay|] do
        let numMature = numPerCounter.[0]
        for index in [|1..numPerCounter.Length-1|] do
            numPerCounter.[index - 1] <- numPerCounter.[index]
        numPerCounter.[8] <- numMature // new fish
        numPerCounter.[6] <- numPerCounter.[6] + numMature

    numPerCounter |> Array.sum
```
Result: `1622533344325`

## [D7](AofC_2021/D7.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D7.txt)  
### part1
```
let part1 input =
    calc (parseInput input) (fun p1 p2 -> abs(p1 - p2))
```
Result: `336040`
### part2
```
let part2 input =
    calc (parseInput input) (fun p1 p2 -> 
        let diff = abs(p1 - p2)
        diff * (diff + 1) / 2
    )
```
Result: `94813675`

## [D8](AofC_2021/D8.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D8.txt)  
### part1
```
let part1 input =
    let data = parseInput input

    let numberToSegments = digitsWithSegments |> Array.map (fun f -> (f.Digit, f.Segments)) |> Map.ofArray
    let byNumSegments = [| for (KeyValue(k, v)) in numberToSegments -> (k, v.Length) |] |> Array.groupBy (fun f -> snd f)
    let singleInstances = byNumSegments |> Array.filter (fun f -> (snd f).Length = 1)
    let singleInstanceSegmentCounts = singleInstances |> Array.map (fun f -> fst f)

    let outputLengths = data |> Array.map (fun f -> f.Output |> Array.map (fun item -> item.Length))
                        |> Array.reduce Array.append

    let counts = outputLengths |> Array.filter (fun f -> singleInstanceSegmentCounts |> Array.contains f ) |> Array.length
    counts
```
Result: `445`
### part2
```
let part2 input =
    let data = parseInput input
    // Note: Wanted to "brute force" by identifying the digit segments, then translating to digits

    let groupBySegment arrWithSegments  =
        let all = arrWithSegments |> Array.map (fun f -> f.Segments) |> String.concat "" |> Seq.toArray |> Array.distinct
        all |> Array.map (fun char -> 
            let containedIn = arrWithSegments |> Array.filter (fun ds -> (ds.Segments).Contains(char)) |> Array.map (fun f -> f.Digit)
            {| Segment = char; ContainedIn = containedIn |}
        )
    
    let getUniqueFreqs segFreqs =
        segFreqs |> Array.groupBy (fun (f: {| ContainedIn: 'a[]; Segment: char; |}) ->
            f.ContainedIn |> Array.length) |> Array.filter (fun f -> (snd f).Length = 1) |> Array.map (fun f -> (snd f).[0])

    let removeSegments digSeg segments =
        digSeg |> Array.map (fun f -> { f with Segments = removeCharsFromString f.Segments segments })

    let identifySegments sigsegs =
        let uniqueSegFreqs = getUniqueFreqs (groupBySegment sigsegs) |> Array.sortBy (fun f -> f.ContainedIn.Length)
        let identifiedSeqments = mapToString uniqueSegFreqs (fun f -> f.Segment)

        let withSingleAfterRemoval segmentsToRemove (ignoreSegments: string) =
            let withRemoved = removeSegments sigsegs segmentsToRemove
            withRemoved |> Array.filter (fun f -> f.Segments.Length = 1) 
                    |> Array.filter (fun f -> ignoreSegments.Contains(f.Segments) = false)
                    |> Array.tryExactlyOne

        let identifySegment segmentsToRemove =
            let combos = segmentsToRemove |> getCombinationsString
            let found = combos |> List.map (fun combo -> withSingleAfterRemoval combo segmentsToRemove) |> List.tryFind (fun f -> f.IsSome)
            let foundOption = if found.IsSome && found.Value.IsSome then Some(found.Value.Value) else None
            foundOption

        let foldResult = [|0..7|] |> Array.fold (fun (agg: {| IdentifiedSegments: string; Continue: bool; |}) curr -> 
                                if agg.Continue = false then agg
                                else
                                let found = identifySegment agg.IdentifiedSegments
                                let segments = agg.IdentifiedSegments + if found.IsNone then "" else found.Value.Segments.[0].ToString()
                                {| IdentifiedSegments = segments; Continue = found.IsSome; |}
                            ) {| IdentifiedSegments = identifiedSeqments;  Continue = true |}
        foldResult.IdentifiedSegments

    let realOrder = identifySegments digitsWithSegments |> Seq.toArray
    let segmentsToDigit = Map (Array.zip(digitsWithSegments |> Array.map (fun f -> f.Segments)) (digitsWithSegments |> Array.map (fun f -> f.Digit)))

    let translateInputToReal digSeg output =
        let inputOrder = identifySegments digSeg |> Seq.toArray
        let inputSegment2Real = Map (Array.zip inputOrder realOrder)
        let translatedInputSegments = output |> Array.map Seq.toArray 
                                        |> Array.map (fun f -> f |> Array.map (fun c -> inputSegment2Real.[c]) |> Array.sort |> Array.map string |> String.concat "")
        let digits = translatedInputSegments |> Array.map (fun f -> segmentsToDigit.[f])
        digits |> Array.map string |> String.concat "" |> int

    let translatedOutput = data |> Array.map (fun f -> translateInputToReal f.SignalNormalized f.Output)
    let sum = translatedOutput |> Array.sum
    sum
```
Result: `1043101`

## [D9](AofC_2021/D9.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D9.txt)  
### part1
```
let part1 input =
    let map = createDepthMap input
    map.findLowPoints |> Array.map map.getAtPoint |> Array.map (fun f -> f + 1) |> Array.sum
```
Result: `535`
### part2
```
let part2 input =
    let map = createDepthMap input

    let visited = new System.Collections.Generic.List<Point>()
    let basinsBySize = map.findLowPoints |> Array.map (fun f -> exploreBasin map f visited |> List.toArray) |> Array.sortBy (fun f -> f.Length) |> Array.rev

    let html = basinsToHtml map basinsBySize
    System.IO.File.WriteAllText(@"Basins.html", html);
    let top3 = basinsBySize |> Array.take 3
    top3 |> Array.map (fun f -> f.Length) |> Array.reduce (fun agg curr -> agg * curr)
```
Result: `1122700`

## [D10](AofC_2021/D10.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D10.txt)  
### part1
```
let part1 (input: string) =
    let data = parseInput input
    let analyzed = data |> Array.map (fun f -> {| Line = f; Analysis = findCorrupt f;|})
    let pointsPt1 = Map([(')', 3); (']', 57); ('}', 1197); ('>', 25137)])
    analyzed
        |> Array.filter (fun f -> f.Analysis.Corrupt)
        |> Array.map (fun f -> f.Line.[f.Analysis.LastIndex])
        |> Array.map (fun f -> pointsPt1.[f])
        |> Array.sum
```
Result: `318081`
### part2
```
let part2 (input: string) =
    let data = parseInput input
    let analyzed = data |> Array.map (fun f -> {| Line = f; Analysis = findCorrupt f;|})
    let pointsPt2 = Map([(')', 1); (']', 2); ('}', 3); ('>', 4)])
    let part2 = analyzed
                |> Array.filter (fun f -> f.Analysis.Corrupt = false)
                |> Array.map (fun f -> f.Analysis.Stack |> List.map (fun c -> pointsPt2.[getMatchingChar c]) |> List.map int64 |> List.reduce (fun agg c -> agg * 5L + c))
                |> Array.sort
    part2.[part2.Length / 2]
```
Result: `4361305341`

## [D11](AofC_2021/D11.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D11.txt)  
### part1
```
let part1 input =
    let data = prepare input
    let (_, numFlashes) = [|1..100|] |> Array.fold (fun agg curr -> 
                                    let state = performStep (fst agg) data.Size
                                    let numFlashes = state |> Array.filter (fun f -> f = 0) |> Array.length
                                    (state, (snd agg) + numFlashes)
                                    ) (data.Values, 0)
    numFlashes
```
Result: `1679`
### part2
```
let part2 input =
    let data = prepare input
    let rec folder vals step =
        let state = performStep vals data.Size
        if state |> Array.filter (fun f -> f > 0) |> Array.length = 0 then step
        else folder state step + 1
    folder data.Values 1
```
Result: `519`

## [D12](AofC_2021/D12.fs)
[Data file](AofC_2021/C:\Users\jonas\Documents\dev\AofC_2021\AofC_2021\bin\Debug\net5.0\D12.txt)  
### part1
```
let part1 input =
    let pairs = parseInput input
    let paths = evaluate pairs (fun f ->  if f.ToUpper() = f then -1 else 1)
    paths.Length
```
Result: `4413`
### part2
```
let part2 input =
    let pairs = parseInput input
    let allSmall = (getNodes pairs) |> Array.filter (fun f -> f.ToLower() = f) |> Array.except [| "start"; "end" |]
    let allPaths = allSmall |> Array.map (fun small -> 
        evaluate pairs (fun f -> if f.ToUpper() = f then -1 else if f = small then 2 else 1)
    )

    let distinct = allPaths |> Array.reduce Array.append |> Array.distinct
    distinct.Length
```
Result: `118803`
